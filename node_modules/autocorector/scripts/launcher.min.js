(()=>{var e=[,e=>{"use strict";e.exports=require("fs")},e=>{"use strict";e.exports=require("path")},e=>{"use strict";e.exports=require("chalk")},(e,o,s)=>{const t=s(1).promises,r=(s(1),s(5)),a=s(6),n=s(2),i=s(3),c=s(7),l=s(8),d=s(9),u=s(10),p={},g=i.bgRed,h=i.green,m=i.bgCyan,b=i.yellow.inverse,f=i.bgGreen,v=i.green,w=i.bgBlue,y=i.bgMagenta;let E=!1,x=!1;const F=process.env.MIRIADAX;p.setDebug=e=>{E=e},p.debug=(...e)=>{E&&console.log(...e)},p.setDevLogs=e=>{x=e},p.devLog=(...e)=>{x&&console.log(...e)},p.getConfig=async()=>{if(p.devLog("getConfig"),p.debug("Obteniendo la configuración del package.json"),!await p.checkFileExists("package.json"))return Promise.reject(new Error("Esto no parece un repositorio Git, no tiene package.json. No se puede usar el corrector automático. Se ejecutó desde la ruta: "+process.cwd()));try{const e=JSON.parse(await t.readFile(n.resolve(process.cwd(),"package.json")));return Promise.resolve(e)}catch(e){return p.debug("Error procesando el package.json",e),Promise.reject(e)}},p.processArguments=e=>{p.debug("processArguments",e);let o={};e.slice(2);return e.forEach(((s,t)=>{"--help"===s&&(console.log("Usage:"),console.log("autocorector [--help] [--debug] [--jest] [--upload] [--saveLog <filename>] [--port <port>] [--path <path>] [--upload]"),console.log(""),console.log("Options:"),console.log("--help                Muestra este mensaje de ayuda y cierra (no admite más parámetros si --help está presente)"),console.log("--debug               Muestra información de depuración"),console.log("--jest                Ejecuta los tests de Jest"),console.log("--upload              Subir los resultados a Moodle"),console.log("--saveLog <filename>  Guarda los resultados en un archivo de nombre filename"),console.log("--port <port>         Port to use"),console.log("--path <path>         Path to use"),console.log(""),process.exit(0)),"--debug"===s&&(console.log("DEBUG MODE ACTIVATED VIA ARGUMENT --DEBUG"),p.setDebug(!0),o.debug=!0),"--jest"===s&&(o.jest=!0),"--port"===s&&(console.log("TODO - USAR PORT"),o.port=e[t+1]),"--path"===s&&(console.log("TODO - USAR PATH"),o.path=e[t+1]),"upload"!==s&&"--upload"!==s&&"-u"!==s||(o.upload=!0),"--saveLog"===s&&(o.saveLog=!0,o.saveLogFilename=e[t+1])})),o},p.checkFileExists=async e=>{p.devLog("checkFileExists",e);try{return await t.access(e,t.F_OK),!0}catch(e){return!1}},p.createFolder=async e=>{p.devLog("createFolder",e),await p.checkFileExists(n.resolve(process.cwd(),e))||(p.debug("Data folder does not exist, let's create it"),await t.mkdir(e))},p.getEmailAndToken=async(e,o="autocorector")=>{p.devLog("getEmailAndToken method for userfile and endpoint:",e,o),p.debug("Obteniendo el nombre, el email y el token del usuario.");let s={};const r=o.match(/moocauto/i);if(await p.checkFileExists(n.resolve(process.cwd(),e)))try{return s=JSON.parse(await t.readFile(n.resolve(process.cwd(),e))),Promise.resolve(s)}catch(e){return p.debug("Error procesando el fichero de usuario",e),Promise.reject(new Error("El fichero con la información del usuario contiene información inválida. La dirección de correo electrónico debe ser del dominio upm.es"))}const i=a.createInterface({input:process.stdin,output:process.stdout}),c=r?"Escriba su email con el que accede a MiriadaX:  ":"Escriba su email de alumno UPM:  ",l=r?"Escriba su token de MiriadaX:  ":"Escriba su token de Moodle UPM: ";return new Promise((function(o,r){console.log(h("A continuación se pedirán sus datos (nombre, email y token) para subir sus resultados")),i.question(h("Escriba su nombre y apellidos: "),(function(a){s.name=a,i.question(h(c),(function(a){s.email=a,i.question(h(l),(async a=>{s.token=a;try{await t.writeFile(n.resolve(process.cwd(),e),JSON.stringify(s,null,4)),p.debug("Fichero user.json creado con la información provista por el usuario")}catch(e){console.log(g(e)),r(new Error("NO SE HA PODIDO CREAR EL FICHERO USER.JSON"))}i.close(),o(s)}))}))}))}))},p.generateRandomUserId=()=>{p.devLog("generateRandomUserId");const e=(new Date).valueOf().toString(),o=Math.random().toString();return r.createHash("sha1").update(e+o).digest("hex")},p.getHashMultipleFiles=async e=>{p.devLog("getHashMultipleFiles",e);let o="";for(let s=0;s<e.length;s++)o+=await t.readFile(n.resolve(process.cwd(),e[s]),"utf8");o=o.replace(/  |\r\n|\n|\r/gm,"");return r.createHash("md5").update(o).digest("hex")},p.getHashString=e=>{p.devLog("getHashString");let o="";o=e.replace(/  |\r\n|\n|\r/gm,"");return r.createHash("md5").update(o).digest("hex")},p.getSignature=e=>{p.debug("getSignature");return r.createHmac("sha512","new JSON({user_info})").update(JSON.stringify(e)).digest("hex")},p.askForDataCorrect=e=>{p.devLog("askForDataCorrect",e);const o=a.createInterface({input:process.stdin,output:process.stdout});return new Promise((function(s,t){console.log(h(`Los datos con los que se va a firmar la práctica son, email: ${e.email}, token: ${e.token}`)),o.question(m("¿Son correctos? (y/N): "),(function(e){s("y"===e||"yes"===e,t),o.close()}))}))},p.askForConsent=()=>{p.devLog("askForConsent");const e=a.createInterface({input:process.stdin,output:process.stdout});return new Promise((function(o,s){console.log(h("El contenido de la práctica, así como los test que se le pasan van a ser firmados.")),console.log(h("Es importante que sepa que se van a enviar al servidor y en él se validará la firma y la autenticidad, así como se pasará un anticopia.")),e.question(m("¿Confirma que ha realizado usted mismo la práctica y desea enviarla al servidor para registrar la nota? (y/N):\n"),(t=>{o("y"===t||"yes"===t,s),e.close()}))}))},p.checkCaptures=async(e,o)=>{if(p.devLog("checkCaptures",e,o),!await p.checkFileExists(n.resolve(process.cwd(),e)))return p.debug("Directorio para las capturas no existe. Debería ser: "+n.resolve(process.cwd(),e)),!1;return(await t.readdir(n.resolve(process.cwd(),e))).length>=o},p.askForResearchConsent=e=>{p.devLog("askForResearchConsent",e);const o=a.createInterface({input:process.stdin,output:process.stdout});return new Promise((function(e,s){o.question(m("Al hacer uso de esta herramienta se recogerán datos anónimos para uso exclusivo de investigación. Si desea continuar pulse 'Y'. En caso contrario, pulse 'N'\n"),(t=>{e("y"===t||"Y"===t||"yes"===t,s),o.close()}))}))},p.compress=async e=>{p.devLog("compress",e),p.debug("Comprimiendo archivos...");const o=c("zip",{zlib:{level:9}}),s=(await t.open(n.resolve(process.cwd(),e),"w")).createWriteStream();return new Promise(((e,t)=>{o.glob("**",{ignore:["node_modules/**","**/node_modules/**","tests/**","bin/**","README.md","LICENSE","*.zip","autocorector/data/*.zip"]}),o.glob("autocorector/data/res.enc"),o.on("error",(e=>{p.devLog(e),t(e)})),o.on("warning",(function(e){if(p.devLog(e),"ENOENT"!==e.code)throw e})),o.pipe(s),s.on("close",(()=>{const s=o.pointer()/1048576;p.debug("El fichero zip creado ocupa "+s+" MB"),e(+s.toFixed(2))})),o.finalize()}))},p.checkHash=async(e,o,s)=>{p.devLog("checkHash",e,o,s),p.debug("Comprobando el hash de los ficheros para ver que no se ha modificado ninguno...");let r=[];const a=await t.readdir(o);for(const e of a)p.debug("Test file encontrado: "+e),r.push(n.join(o,e));if(null!=s&&""!==s){const e=await t.readdir(s);for(const o of e)p.debug("Utils file encontrado: "+o),r.push(n.join(s,o))}const i=await p.getHashMultipleFiles(r);p.devLog("Local hash",i);let c="";for(const o of r)c+=await p.getGitHubFileAsString(e,o);const l=p.getHashString(c);p.devLog("Github hash de los ficheros",l),p.debug("Hash remoto, hash local:",i,l),i!==l?(console.log(g("WARNING: se ha detectado que el fichero de tests es diferente al oficial, esto dará problemas al subir la nota al servidor. Puede ser que los profesores hayan realizado modificaciones o arreglos de los tests publicados.")),console.log(g(`Si ha utilizado git para descargar la práctica ejecute las ordenes 'git pull' y 'git checkout ${o}*' para volver a obtener la versión oficial de los tests, o si no ha usado git para descargar la práctica vuelva a sustituir ${o}* por una copia recien descargada del repositorio.`))):p.debug("Ficheros de tests sin modificar")},p.rawGitHubUrl=(e,o,s,t)=>`https://raw.githubusercontent.com/${e}/${o}/${t}/${s}`,p.downloadFileFromGitHubSingle=async(e,o,s,t)=>{try{const r=p.rawGitHubUrl(e,o,s,t);p.debug("Download from Github URL: "+r);const a=await l("get",r);if(a.statusCode>=400&&a.statusCode<=500)throw new Error("Error in request "+a.statusCode);return a.body}catch(e){return p.debug("Error in downloadFileFromGitHubSingle",e),"*"}},p.downloadFileFromGitHub=async(e,o,s,t)=>{let r=await p.downloadFileFromGitHubSingle(e,o,s,t);return"*"===r&&(r=await p.downloadFileFromGitHubSingle(e,o,s,"main"),"*"===r&&(r=await p.downloadFileFromGitHubSingle(e,o,s,"master"))),p.devLog("downloadFileFromGitHub resultado:",r),r},p.checkTestVersion=async(e,o,s="main")=>{p.devLog("checkTestVersion",e,o),p.debug("Comprobando la versión de los tests...");const[t,r]=e.split("/");try{const e=await p.downloadFileFromGitHub(t,r,"package.json",s);if(p.debug(e),"*"===e)throw new Error;return JSON.parse(e).version}catch(e){return"*"}},p.getGitHubFileAsString=async(e,o,s="main")=>{p.devLog("getGitHubFileAsString",e,o,s);const[t,r]=e.split("/");let a=o;a.startsWith("./")&&(a=a.substring(2));try{const e=await p.downloadFileFromGitHub(t,r,a,s);return Buffer.from(e).toString()}catch(e){throw new Error(e)}},p.encryptBufferWithRsaPublicKey=async(e,o)=>{p.devLog("encryptBufferWithRsaPublicKey");const s=await t.readFile(n.resolve(process.cwd(),o),"utf8"),a=Buffer.from(e);return r.publicEncrypt({key:s,padding:r.constants.RSA_NO_PADDING},a).toString("base64")},p.en=(e,o)=>{p.devLog("en");const s=r.createHash("sha256").update(o).digest("base64").substr(0,32),t=r.randomBytes(16),a=r.createCipheriv("aes-256-ctr",s,t),n=Buffer.from(e);return Buffer.concat([t,a.update(n),a.final()]).toString("hex")},p.de=(e,o)=>{p.devLog("de");let s=Buffer.from(e,"hex");const t=s.slice(0,16);s=s.slice(16);const a=r.createHash("sha256").update(o).digest("base64").substr(0,32),n=r.createDecipheriv("aes-256-ctr",a,t);return Buffer.concat([n.update(s),n.final()]).toString()},p.sendFile=async(e,o,s)=>{p.devLog("sendFile",e,o),console.log("Enviando práctica al servidor...");const t={submission:{file:n.resolve(process.cwd(),o),filename:"submission.zip",content_type:"application/zip"}};try{const o={multipart:!0,accept:"application/json"},r=await l("post",e,t,o);200===r.statusCode?(console.log(h(r.body||"Ok")),await p.cleanHistoryRecords(s)):(console.log(g("ERROR")),console.error(r.body||"Error"))}catch(e){console.error(e||"Error")}},p.sendLog=async(e,o,s)=>{p.devLog("sendLog",e,o,s);const r={history:await t.readFile(n.resolve(process.cwd(),s),"utf8")};try{const o={accept:"application/json"},t=await l("post",e,r,o);200===t.statusCode?(p.debug("sendLog",h(t.body||"OK")),await p.cleanHistoryRecords(s)):(p.debug("sendLog",g("ERROR")),p.debug("sendLog",t.body||"Respuesta errónea del servidor"))}catch(e){p.debug("sendLog",e||"Error subiendo a servidor")}},p.execTestsJest=e=>(p.devLog("execTestsJest",e),new Promise((o=>{const t={score:0,score_total:10};p.debug("Ejecutando nueva test suite de JEST:");const{runCLI:r}=s(11),a={testMatch:["**/**/*.[jt]s?(x)"],roots:["<rootDir>"+e],setupFiles:["react-app-polyfill/jsdom"],setupFilesAfterEnv:["<rootDir>/scripts/jest/jest-setup.js"],testEnvironment:"jsdom",transform:{"^.+\\.(js|jsx|mjs|cjs|ts|tsx)$":"<rootDir>/scripts/jest/babelTransform.js","^.+\\.css$":"<rootDir>/scripts/jest/cssTransform.js","^(?!.*\\.(js|jsx|mjs|cjs|ts|tsx|css|json)$)":"<rootDir>/scripts/jest/fileTransform.js"},verbose:!0,maxWorkers:"1",transformIgnorePatterns:["[/\\\\]node_modules[/\\\\].+\\.(js|jsx|mjs|cjs|ts|tsx)$","^.+\\.module\\.(css|sass|scss)$"],modulePaths:[],moduleNameMapper:{"^react-native$":"react-native-web","^.+\\.module\\.(css|sass|scss)$":"identity-obj-proxy"},moduleFileExtensions:["js","jsx"],reporters:[["<rootDir>/scripts/jest/custom-reporter.js",{banana:"yes",pineapple:"no"}]],testSequencer:"<rootDir>/scripts/jest/test-sequencer.js"};r({config:JSON.stringify(a)},[process.cwd()]).then((e=>{p.debug("JEST test suite terminada con éxito.");for(let o=0;o<e.results.testResults.length;o++)for(let s=0;s<e.results.testResults[o].testResults.length;s++)if("passed"===e.results.testResults[o].testResults[s].status){let r=JSON.parse(e.results.testResults[o].testResults[s].title);t.score+=r.score}o(t)})).catch((e=>{p.debug("JEST test suite terminada con un error:"),console.error(e),o(t)}))}))),p.execTests=e=>(p.devLog("execTests",e),new Promise((async o=>{global.should=s(12).should(),global.exec=u.promisify(s(13).exec),global.Browser=s(14);const r={score:0,score_total:0};let a;p.debug("Call new Mocha test suites:");const i=new d({timeout:6e4,reporter:function(){}});try{a=await t.readdir(e);for(const o of a)p.debug("Añadiendo fichero de test: "+o),i.addFile(n.join(e,o))}catch(e){console.error(e)}i.loadFilesAsync().then((()=>{i.run((e=>process.exitCode=e?1:0)).on("suite",(function(e){console.log(`${b(e.title)}\n`)})).on("test",(function(e){console.log(f(`Test: ${e.title}`))})).on("pass",(function(e){r.score+=e.ctx.score,r.score_total+=e.ctx.score,console.log(`\t${v("ESTADO: ")}${f("PASSED")}`),console.log(`\t${v("PUNTUACIÓN: ")}${e.ctx.score}/${e.ctx.score}`),console.log(`\t${v("OBSERVACIONES: ")}${e.ctx.msg_ok} \n`),console.log(`${w("--------------------------------------------------------------------------------")} \n`)})).on("fail",(function(e,o){try{e.title.indexOf('"after all" hook')<0&&e.title.indexOf('"before all" hook')<0?(r.score_total+=e.ctx.score,console.log(`\t${v("ESTADO: ")}${g("FAILED")}`),console.log(`\t${g("PUNTUACIÓN: ")}0/${e.ctx.score}`),console.log(`\t${g("OBSERVACIONES:")}${e.ctx.msg_err}`)):console.log(g("ERROR TEST MOCHA: ")+o),p.debug(g("Ha fallado el test o se ha producido una excepción.")),p.debug("El error es:",o);const s=new RegExp("\\((.+("+a.join("|")+").+?)\\)","g"),t=o.stack.match(s);if(t){let e=t[0];const o=new RegExp("\\:(\\d*?)\\:"),s=e.match(o),r=e.split(":"+s[1]+":")[0];s.length>=0&&!r.startsWith("node_modules")&&console.log(y(`\tEl test que ha fallado está en el fichero: ${r.substr(1)} en la línea ${s[1]}. Puedes abrir el fichero y ver qué comprobación está fallando.\n`))}console.log(`${w("--------------------------------------------------------------------------------")} \n`)}catch(o){console.log(o)}})).on("end",(function(){r.score=parseFloat(r.score.toPrecision(12)),r.score_total=parseFloat(r.score_total.toPrecision(12)),o(r)}))})).catch((e=>{console.log("CATCH: ",e)}))}))),p.initHistory=async()=>{p.devLog("initHistory");const e=[],o={},s=await t.stat("package.json");return o.started=!0,o.datetime=s.mtime,F&&(o.userId=p.generateRandomUserId()),e.push(o),e},p.saveHistoryRecord=async(e,o,s)=>{p.devLog("saveHistoryRecord",e,o);let r=!1;if(await p.checkFileExists(n.resolve(process.cwd(),s)))try{const e=await t.readFile(n.resolve(process.cwd(),s),"utf8"),o=p.de(e,"pubkey.pem");r=JSON.parse(o)}catch(e){console.log("ERROR Recuperable: ",g(e)),p.debug(e),r=await p.initHistory()}else r=await p.initHistory();const a={started:!1,datetime:new Date,score:e.score,score_total:e.score_total,version:o,autoCOREctorVersion:"3.0.2"};r.push(a);const i=p.en(JSON.stringify(r,null,4),"pubkey.pem");try{return await t.writeFile(n.resolve(process.cwd(),s),i,"utf8"),r}catch(e){return console.log(g(e)),e}},p.cleanHistoryRecords=async e=>{if(p.devLog("cleanHistoryRecords"),await p.checkFileExists(n.resolve(process.cwd(),e))){const o=await t.readFile(n.resolve(process.cwd(),e),"utf8"),s=p.de(o,"pubkey.pem"),r=[JSON.parse(s)[0]],a=p.en(JSON.stringify(r,null,4),"pubkey.pem");return t.writeFile(n.resolve(process.cwd(),e),a,"utf8")}},e.exports=p},e=>{"use strict";e.exports=require("crypto")},e=>{"use strict";e.exports=require("readline")},e=>{"use strict";e.exports=require("archiver")},e=>{"use strict";e.exports=require("needle")},e=>{"use strict";e.exports=require("mocha")},e=>{"use strict";e.exports=require("util")},e=>{"use strict";e.exports=require("@jest/core")},e=>{"use strict";e.exports=require("chai")},e=>{"use strict";e.exports=require("child_process")},e=>{"use strict";e.exports=require("zombie")}],o={};function s(t){var r=o[t];if(void 0!==r)return r.exports;var a=o[t]={exports:{}};return e[t](a,a.exports,s),a.exports}(()=>{const e=s(1).promises,o=s(2),t=s(3),r=s(4),a="./autocorector/tests",n="./autocorector/data",i="./user.json",c=`${n}/res.enc`,l=`${n}/assignment.zip`,d=`${n}/his.enc`,u=(t.blue,t.bgRed),p=t.green,g=t.bgRed,h=t.bgGreen,{MIRIADAX:m}=process.env;process.env.BABEL_ENV="development",r.getConfig().then((async s=>{let t=r.processArguments(process.argv);if(t.saveLog){const r=(await e.open(o.resolve(process.cwd(),t.saveLogFilename),"w")).createWriteStream();process.stdout.write=process.stderr.write=r.write.bind(r),s.devLogs=!0,s.debug=!0}s.debug&&(console.log("DEBUG MODE ACTIVADO VIA PACKAGE.JSON CONFIG"),r.setDebug(s.debug)),s.devLogs&&(console.log("DEVLOGS MODE ACTIVADO VIA PACKAGE.JSON CONFIG"),r.setDevLogs(s.devLogs));try{const b=await r.checkTestVersion(s.info.githubURL,"package.json",s.info.branch);t.upload||"*"!==b?b!==s.version&&(r.debug("Version de los test del repositorio es: "+b+" y tu version es: "+s.version),console.log(u("No tienes la última versión de los TESTs o no tienes conexión de red. Debes tener conexión de red y además tener la última versión de los test, para ello actualiza el repositorio.")),console.log(p(`Si has utilizado git para bajártelo tan solo tendrás que hacer git pull, si no has usado git vuelve a bajarte el repo completo y sustituye la carpeta ${a} y el fichero package.json por la última versión.`))):console.log(p(`No se ha podido comprobar si tienes la última versión de los test, no hay conexión a Internet o el repositorio remoto ha devuelto un error al intentar acceder. Se empleará la versión ${s.version}`)),t.upload&&b!==s.version&&(r.debug("No se puede subir la práctica por no coincidir la versión de los tests"),process.exit(0)),s.disableHashCheck?r.debug("WARNING: DisableHashCheck opción a 'true', saltando hash check"):(r.debug("Vamos a comprobar el hash de los ficheros de test"),await r.checkHash(s.info.githubURL,a,"./autocorector/utils"));const f=`${s.info.serverUrl}api/${m?"coursesMiriadax":"courses"}/${s.info.courseId}/assignments/${s.info.assignmentId}`;await r.createFolder(n);let v,w=await r.getEmailAndToken(i,s.info.serverUrl);t.jest?(r.debug("Ejecutando tests con JEST"),v=await r.execTestsJest(a)):(r.debug("Ejecutando tests con MOCHA"),v=await r.execTests(a));const y=await r.saveHistoryRecord(v,s.version,d);if(v.score===(v.score_total||10)?console.log(h(`Resultado Final: ${v.score}/${v.score_total}\n\n`)):console.log(g(`Resultado Final: ${v.score}/${v.score_total}\n\n`)),t.saveLogs&&(myfilehandle.close(),console.log(h(`Se ha creado el fichero ${t.saveLogFilename} con los logs de la práctica, ya los puedes mandar junto con el zip de la práctica (sin node_modules) al profesor.`)),process.exit(0)),t.upload){await r.askForDataCorrect(w)||(await r.checkFileExists(o.resolve(process.cwd(),i))&&await e.unlink(o.resolve(process.cwd(),i)),w=await r.getEmailAndToken(i,s.info.serverUrl));if(await r.askForConsent()||(console.log(u("Asegurese de haber hecho usted la práctica que va a subir al servidor.")),process.exit(0)),s.capturesNumber&&s.capturesNumber>0){const e=void 0===s.capturesFolder?"capturas":s.capturesFolder;await r.checkCaptures(e,s.capturesNumber)||(console.log(u(`No se han encontrado las capturas de pantalla requeridas. Se necesitan ${s.capturesNumber} capturas en el directorio ${o.resolve(process.cwd(),e)}`)),process.exit(0))}w.score=v.score,w.score_total=v.score_total,w.test_version=s.version,w.history=y,w.has_disabled_has_check_in_config=s.disableHashCheck;const t=JSON.parse(JSON.stringify(w));w.signature=r.getSignature(t),r.devLog("RESULTS: ",w);const a=r.en(JSON.stringify(w,null,4),"pubkey.pem");await e.writeFile(o.resolve(process.cwd(),c),a);await r.compress(l)>20?console.log(u("ERROR CRITICO. El fichero zip creado para la práctica supera el tamaño máximo permitido de 20MB. El corrector comprime todo lo que está en la carpeta del proyecto excepto el node_modules, asegurese de que no ha puesto archivos adicionales en la carpeta de la práctica, solo los requeridos para solucionarla.")):await r.sendFile(f,l,d),r.debug("¡FIN!")}else console.log(g("Este resultado es informativo. Debe ejecutar el autocorector con la opción -u o --upload para subir su nota y que quede registrada.")),console.log(h("Recuerde que puede subir su nota varias veces, se quedará con la última nota que haya subido cuando se cierre la entrega de la práctica."))}catch(e){console.log("ERROR, CERRAMOS TODO"),console.log(u(e)),console.log(e)}})).catch((e=>{r.debug(e),console.log(u(e))}))})()})();