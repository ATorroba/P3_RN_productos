/* eslint-disable space-before-blocks */
/* eslint-disable newline-after-var */
/* eslint-disable indent */
const fs = require("fs").promises;
const fsnopromises = require("fs");
const crypto = require("crypto");
const readline = require("readline");
const path = require("path");
const chalk = require("chalk");
const archiver = require("archiver");
const needle = require("needle");
const Mocha = require("mocha");
const nodeutil = require("util"); // node util module
var { execSync } = require('child_process');


const Utils = {}; // define our Utils module

const error = chalk.bgRed;
const info = chalk.green;
const ask = chalk.bgCyan;
const suiteTitle = chalk.yellow.inverse;
const testTitle = chalk.bgGreen;
const highlight = chalk.green;
const blueinfo = chalk.bgBlue;
const magentainfo = chalk.bgMagenta;

let withDebug = false;
let withDevLogs = false;

const AUTOCORECTOR_VERSION  = process.env.AUTOCORECTOR_VERSION;
const MIRIADAX = process.env.MIRIADAX;

Utils.setDebug = (status) => {
    withDebug = status;
};

Utils.debug = (...args) => {
    if (withDebug) {
        console.log(...args);
    }
};

//segundo nivel de logs, logs de developer
Utils.setDevLogs = (status) => {
    withDevLogs = status;
}

Utils.devLog = (...args) => {
    if (withDevLogs) {
        console.log(...args);
    }
};

/* get config from package.json, done this way instead of require because requires are resolved by webpack when uglifying*/
Utils.getConfig = async () => {
    Utils.devLog("getConfig");
    Utils.debug("Obteniendo la configuración del package.json");
    if (await Utils.checkFileExists("package.json")) {
        try {
            const config = JSON.parse(await fs.readFile(path.resolve(process.cwd(), "package.json")));

            return Promise.resolve(config);
        } catch (err) {
            Utils.debug("Error procesando el package.json", err);
            return Promise.reject(err);
        }
    } else {
        return Promise.reject(new Error("Esto no parece un repositorio Git, no tiene package.json. No se puede usar el corrector automático. Se ejecutó desde la ruta: " + process.cwd()));
    }
};

/* Process arguments */
Utils.processArguments = (argv) => {
    Utils.debug("processArguments", argv);
    let options = {};
    let args = argv.slice(2);

    argv.forEach((arg, index) => {
        if (arg === "--help") {
            console.log("Usage:");
            console.log("autocorector [--help] [--debug] [--jest] [--jestnative] [--upload] [--saveLog <filename>] [--version] [--upload]");
            console.log("");
            console.log("Options:");
            console.log("--help                Muestra este mensaje de ayuda y cierra (no admite más parámetros si --help está presente)");
            console.log("--debug               Muestra información de depuración");
            console.log("--jest                Ejecuta los tests de Jest");
            console.log("--jestnative          Ejecuta los tests de Jest con React Native");
            console.log("--upload              Subir los resultados a Moodle");
            console.log("--saveLog <filename>  Guarda los resultados en un archivo de nombre filename");
            console.log("--version             Comprueba la versión del autocorector instalada");
            console.log("--path <path>         Path to use");
            console.log("");
            process.exit(0);
        }
        if (arg === "--debug") {
            console.log("DEBUG MODE ACTIVATED VIA ARGUMENT --DEBUG");
            Utils.setDebug(true);
            options.debug = true;
        }        
        if (arg === "--jest") {
            options.jest = true;
        }
        if (arg === "--jestnative") {
            options.jestnative = true;
        }
        if (arg === "--port") {
            console.log("TODO - USAR PORT");
            options.port = argv[index + 1];
        }
        if (arg === "--path") {
            console.log("TODO - USAR PATH");
            options.path = argv[index + 1];
        }
        if (arg === "upload" || arg === "--upload" || arg === "-u") {
            options.upload = true;
        }
        if (arg === "--saveLog") {
            options.saveLog = true;
            options.saveLogFilename = argv[index + 1];
        }
        if (arg === "--version" || arg==="-v") {
				var currentVersion = require('../package.json').version;
				var latestVersion = undefined;
				try {
					latestVersion = execSync("npm show autocorector version").toString().trim();
					if (latestVersion === currentVersion) {
						console.log("Tienes la última versión del autoCOREctor (" + currentVersion + ")\n")
					} else {
						console.log("No tienes la última versión del autoCOREctor (" + latestVersion + "). La versión instalada es la " + currentVersion);
						console.log("\nPara actualizarlo ejecuta \"npm update autocorector\"");

					}
				} catch (err) {
					console.error ("No se ha podido comprobar si el autoCOREctor está utilizando la última versión. La versión instalada es la " + currentVersion);
                    console.log(err);
				}
				process.exit(0);
        }
    });
    return options;
}


Utils.checkFileExists = async (filepath) => {
    Utils.devLog("checkFileExists", filepath);
    try {
        await fs.access(filepath, fs.F_OK);
        return true;
    } catch (err) {
        return false;
    }
};


Utils.createFolder = async (folderpath) => {
    Utils.devLog("createFolder", folderpath);
    if (!await Utils.checkFileExists(path.resolve(process.cwd(), folderpath))) {
        Utils.debug("Data folder does not exist, let's create it");
        await fs.mkdir(folderpath);
    }
};

Utils.getEmailAndToken = async (user_file_path, endpoint = "autocorector") => {
    Utils.devLog("getEmailAndToken method for userfile and endpoint:", user_file_path, endpoint);
    Utils.debug("Obteniendo el nombre, el email y el token del usuario.");
    let user_info = {};
    const isNewMiriada = endpoint.match(/moocauto/i)
    if (await Utils.checkFileExists(path.resolve(process.cwd(), user_file_path))) {
        try{
            user_info = JSON.parse(await fs.readFile(path.resolve(process.cwd(), user_file_path)));
            return Promise.resolve(user_info);
        } catch (err) {
            Utils.debug("Error procesando el fichero de usuario", err);
            return Promise.reject(new Error("El fichero con la información del usuario contiene información inválida."));
        }
    }
    const rl = readline.createInterface({
        "input": process.stdin,
        "output": process.stdout
    });
    
    const name_prompt = "Escriba su nombre y apellidos: ";
    const email_prompt = isNewMiriada ? "Escriba su email con el que accede a MiriadaX:  ":"Escriba su email de alumno:  "
    const token_prompt = isNewMiriada ? "Escriba su token de MiriadaX:  ":"Escriba su token de Moodle: "
    return new Promise(function (resolve, reject) {
        console.log(info("A continuación se pedirán sus datos (nombre, email y token) para subir sus resultados"));
        rl.question(info(name_prompt), function (answer0) {
            user_info.name = answer0;
            rl.question(info(email_prompt), function (answer) {
                user_info.email = answer;
                rl.question(info(token_prompt), async (answer2) => {
                    user_info.token = answer2;
                    try {
                        await fs.writeFile(path.resolve(process.cwd(), user_file_path), JSON.stringify(user_info, null, 4));
                        Utils.debug("Fichero user.json creado con la información provista por el usuario");
                    } catch (err) {
                        console.log(error(err));
                        reject(new Error("NO SE HA PODIDO CREAR EL FICHERO USER.JSON"));
                    }
                    rl.close();
                    resolve(user_info);                   
                });                    
            });
        });
    });
};

Utils.generateRandomUserId = () => {
    Utils.devLog("generateRandomUserId");
    const current_date = new Date().valueOf().toString();
    const random = Math.random().toString();

    return crypto.createHash("sha1").update(current_date + random).digest("hex");
};

Utils.getHashMultipleFiles = async (file_paths_array) => {
    Utils.devLog("getHashMultipleFiles", file_paths_array);
    // first we get the files as a string
    let files_content = "";

    for (let i = 0; i < file_paths_array.length; i++) {
        // eslint-disable-next-line no-await-in-loop
        files_content += await fs.readFile(path.resolve(process.cwd(), file_paths_array[i]), "utf8");
    }
    files_content = files_content.replace((/  |\r\n|\n|\r/gm),"");

    const md5hash = crypto.createHash("md5").update(files_content).digest("hex");
    return md5hash;
};

Utils.getHashString = (mystring) => {
    Utils.devLog("getHashString");
    let files_content = "";

    files_content = mystring.replace((/  |\r\n|\n|\r/gm),"");

    const md5hash = crypto.createHash("md5").update(files_content).digest("hex");
    return md5hash;
};


Utils.getSignature = (user_info) => {
    Utils.debug("getSignature");
    // return objectHash.MD5(user_info);
    // let hash = crypto.createHash('md5');
    // hash.setEncoding('hex');
    // let md5 = hash.update(JSON.stringify(user_info)).digest("hex");
    // return md5;
    const pepper = "new JSON({user_info})";
    const hash = crypto.createHmac("sha512", pepper);
    const hashed_code = hash.update(JSON.stringify(user_info)).digest("hex");

    return hashed_code;
};


Utils.askForDataCorrect = (user_info) => {
    Utils.devLog("askForDataCorrect", user_info);
    const rl = readline.createInterface({
        "input": process.stdin,
        "output": process.stdout
    });

    return new Promise(function (resolve, reject) {
        console.log(info(`Los datos con los que se va a firmar la práctica son, email: ${user_info.email}, token: ${user_info.token}`));

        rl.question(ask("¿Son correctos? (y/N): "), function (answer) {
            if (answer !== "y" && answer !== "yes") {
                resolve(false, reject);
            } else {
                resolve(true, reject);
            }
            rl.close();
        });
    });
};

Utils.askForConsent = () => {
    Utils.devLog("askForConsent");
    const rl = readline.createInterface({
        "input": process.stdin,
        "output": process.stdout
    });

    return new Promise(function (resolve, reject) {
        console.log(info("El contenido de la práctica, así como los test que se le pasan van a ser firmados."));
        console.log(info("Es importante que sepa que se van a enviar al servidor y en él se validará la firma y la autenticidad, así como se pasará un anticopia."));
        rl.question(ask("¿Confirma que ha realizado usted mismo la práctica y desea enviarla al servidor para registrar la nota? (y/N):\n"), (answer2) => {
            if (answer2 !== "y" && answer2 !== "yes") {
                resolve(false, reject);
            } else {
                resolve(true, reject);
            }
            rl.close();
        });
    });
};

Utils.checkCaptures = async (captures_path, captures_number) => {
    Utils.devLog("checkCaptures", captures_path, captures_number);
    if (!await Utils.checkFileExists(path.resolve(process.cwd(), captures_path))) {
        Utils.debug("Directorio para las capturas no existe. Debería ser: " + path.resolve(process.cwd(), captures_path));
        return false;
    }
    const captures = await fs.readdir(path.resolve(process.cwd(), captures_path));
    if (captures.length >= captures_number) {
        return true;
    } else {
        return false;
    }
}



Utils.askForResearchConsent = (user_info) => {
    Utils.devLog("askForResearchConsent", user_info);
    const rl = readline.createInterface({
        "input": process.stdin,
        "output": process.stdout
    });

    return new Promise(function (resolve, reject) {
        rl.question(
            ask("Al hacer uso de esta herramienta se recogerán datos anónimos para uso exclusivo de investigación. Si desea continuar pulse 'Y'. En caso contrario, pulse 'N'\n"),
            (answer2) => {
                if (answer2 !== "y" && answer2 !== "Y" && answer2 !== "yes") {
                    resolve(false, reject);
                } else {
                    resolve(true, reject);
                }
                rl.close();
            }
        );
    });
};

/* devuelve el tamaño en megabytes del zip creado */
Utils.compress = async (outputFilename) => {
    Utils.devLog("compress", outputFilename);
    Utils.debug("Comprimiendo archivos...");
    const archive = archiver("zip", {"zlib": {"level": 9}});
    const myfilehandle = await fs.open(path.resolve(process.cwd(), outputFilename), "w");
    const output = myfilehandle.createWriteStream();

    return new Promise((resolve, reject) => {
        archive.glob("**", {
            "ignore": [
                "node_modules/**",
                "**/node_modules/**",
                "tests/**",
                "bin/**",
                "README.md",
                "LICENSE",
                "*.zip",
                "autocorector/data/*.zip"
            ]
        });

        archive.glob("autocorector/data/res.enc");
        archive.on("error", (err) => {
            Utils.devLog(err);
            reject(err);
        });
        // good practice to catch warnings (ie stat failures and other non-blocking errors)
        archive.on('warning', function(err) {
            Utils.devLog(err);
            if (err.code !== 'ENOENT') {
                throw err;
            }
        });

        archive.pipe(output);

        output.on("close", () => {
            const file_size = archive.pointer();
            const fileSizeInMegabytes = file_size / (1024*1024);
            Utils.debug("El fichero zip creado ocupa " + fileSizeInMegabytes + " MB");
            resolve(+fileSizeInMegabytes.toFixed(2));
        });
        archive.finalize();
    });
};


/* Función que comprueba el hash de los ficheros de tests y de utils con el hash de los ficheros de github a ver si son iguales */
Utils.checkHash = async (githubURL, tests_folder, utils_folder) => {
    Utils.devLog("checkHash", githubURL, tests_folder, utils_folder);
    Utils.debug("Comprobando el hash de los ficheros para ver que no se ha modificado ninguno...");
    //otra opción sería ver con git status si hay cambios en los ficheros de test con https://www.npmjs.com/package/simple-git
    //pero lo hacemos manualmente por si no ha usado git para bajarlo o no tiene el comando git (requerido por simple-git)
    let files_to_check = [];

    const files = await fs.readdir(tests_folder);
    for (const file of files) {
        Utils.debug("Test file encontrado: " + file);
        files_to_check.push(path.join(tests_folder, file));
    }

    if(utils_folder !== undefined && utils_folder !== null && utils_folder !== "") {
        if(await Utils.checkFileExists(utils_folder)){
            const utilsfiles = await fs.readdir(utils_folder);
            for (const file of utilsfiles) {
                Utils.debug("Utils file encontrado: " + file);
                files_to_check.push(path.join(utils_folder, file));
            }
        }
    }

    const myhash = await Utils.getHashMultipleFiles(files_to_check);
    Utils.devLog("Local hash", myhash);

    let stringOfFiles = "";
    for(const file of files_to_check) {
        stringOfFiles += await Utils.getGitHubFileAsString(githubURL, file);
    }
    const newhash = Utils.getHashString(stringOfFiles);
    Utils.devLog("Github hash de los ficheros", newhash);

    Utils.debug("Hash remoto, hash local:", myhash,newhash);
    if (myhash !== newhash) {
        console.log(error("WARNING: se ha detectado que el fichero de tests es diferente al oficial, esto dará problemas al subir la nota al servidor. Puede ser que los profesores hayan realizado modificaciones o arreglos de los tests publicados."));
        console.log(error(`Si ha utilizado git para descargar la práctica ejecute las ordenes 'git pull' y 'git checkout ${tests_folder}*' para volver a obtener la versión oficial de los tests, o si no ha usado git para descargar la práctica vuelva a sustituir ${tests_folder}* por una copia recien descargada del repositorio.`));
    } else {
        Utils.debug("Ficheros de tests sin modificar");
    }
}

Utils.rawGitHubUrl = (owner, repo, filePath, branch) => `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${filePath}`;

Utils.downloadFileFromGitHubSingle = async (owner, repo, filePath, branch) => {
    try {
        const URL = Utils.rawGitHubUrl(owner, repo, filePath, branch);
        Utils.debug("Download from Github URL: " + URL);
        const res = await needle("get", URL);
        if (res.statusCode >= 400 && res.statusCode <= 500) {
            throw new Error("Error in request " + res.statusCode);
        }
        return res.body;
    } catch (err) {
        Utils.debug("Error in downloadFileFromGitHubSingle", err);
        return "*";
    }
}

Utils.downloadFileFromGitHub = async (owner, repo, filePath, branch) => {
    let res = await Utils.downloadFileFromGitHubSingle(owner, repo, filePath, branch);
    if (res === "*") {
        res = await Utils.downloadFileFromGitHubSingle(owner, repo, filePath, "main");
        if (res === "*") {
            res = await Utils.downloadFileFromGitHubSingle(owner, repo, filePath, "master");
        }
    }
    Utils.devLog("downloadFileFromGitHub terminado");
    return res;
};

/* fullrepo is the repo with owner, for example "ebarra/autoCOREctor_client" */
/* jsonPath is the path to the json file inside the repository */
Utils.checkTestVersion = async (fullrepo, jsonPath, branch = "main") => {
    Utils.devLog("checkTestVersion", fullrepo, jsonPath);
    Utils.debug("Comprobando la versión de los tests...");
    const [
        owner,
        repo
    ] = fullrepo.split("/");

    try {
        const res = await Utils.downloadFileFromGitHub(owner, repo, "package.json", branch);
        Utils.debug(res);
        if (res === "*") {
            throw new Error();
        }
        return JSON.parse(res).version;
    } catch (err) {
        return "*";
    }
};

Utils.getGitHubFileAsString = async (fullrepo, filepath, branch = "main") => {
    Utils.devLog("getGitHubFileAsString", fullrepo, filepath, branch);
    const [
        owner,
        repo
    ] = fullrepo.split("/");
    let filePath = filepath;

    if (filePath.startsWith("./")) {
        filePath = filePath.substring(2); // remove the "./"
    }
    try {
        const res = await Utils.downloadFileFromGitHub(owner, repo, filePath, branch);

        return Buffer.from(res).toString();
    } catch (err) {
        throw new Error(err);
    }
};


Utils.encryptBufferWithRsaPublicKey = async (toEncrypt, pathToPublicKey) => {
    Utils.devLog("encryptBufferWithRsaPublicKey");
    const publicKey = await fs.readFile(path.resolve(process.cwd(), pathToPublicKey), "utf8");
    const buffer = Buffer.from(toEncrypt);
    const encrypted = crypto.publicEncrypt({"key": publicKey, "padding": crypto.constants.RSA_NO_PADDING}, buffer);

    return encrypted.toString("base64");
};


// created following https://medium.com/@anned20/encrypting-files-with-nodejs-a54a0736a50a
// method encryptAES
Utils.en = (toEncrypt, key) => {
    Utils.devLog("en");
    // Create an initialization vector
    const algorithm = "aes-256-ctr";
    const newkey = crypto.createHash("sha256").update(key).
        digest("base64").
        substr(0, 32);
    const iv = crypto.randomBytes(16);
    // Create a new cipher using the algorithm, key, and iv
    const cipher = crypto.createCipheriv(algorithm, newkey, iv);
    // Create the new (encrypted) buffer
    const buffer = Buffer.from(toEncrypt);
    const result = Buffer.concat([
        iv,
        cipher.update(buffer),
        cipher.final()
    ]);

    return result.toString("hex");
};

/* Method to decrypt a message*/
Utils.de = (encrypted, key) => {
    Utils.devLog("de");
    let encdata = Buffer.from(encrypted, "hex");
    // Get the iv: the first 16 bytes
    const iv = encdata.slice(0, 16);
    // Get the rest

    encdata = encdata.slice(16);
    // Create a decipher
    const newkey = crypto.createHash("sha256").update(key).
        digest("base64").
        substr(0, 32);

    const decipher = crypto.createDecipheriv("aes-256-ctr", newkey, iv);
    // Actually decrypt it
    const result = Buffer.concat([
        decipher.update(encdata),
        decipher.final()
    ]);

    return result.toString();
};


Utils.sendFile = async (url, file, history_file) => {
    Utils.devLog("sendFile", url, file);
    console.log("Enviando práctica al servidor...");

    const data = {
        "submission": {
            "file": path.resolve(process.cwd(), file),
            "filename": "submission.zip",
            "content_type": "application/zip"
        }
    };

    try {
        const options = {"multipart": true, "accept": "application/json"};

        const response = await needle(
            "post",
            url,
            data,
            options
        );

        if (response.statusCode === 200) {
            console.log(info(response.body || "Ok"));
            await Utils.cleanHistoryRecords(history_file);
        } else {
            console.log(error("ERROR"));

            console.error(response.body || "Error");
        }
    } catch (err) {
        console.error(err || "Error");
    }
};

Utils.sendLog = async (url, user_info, history_file) => {
    Utils.devLog("sendLog", url, user_info, history_file);
    const history_enc_content = await fs.readFile(path.resolve(process.cwd(), history_file), "utf8");

    const data = {
        "history": history_enc_content
    };

    try {
        const options = {"accept": "application/json"};

        const response = await needle("post", url, data, options);

        if (response.statusCode === 200) {
            Utils.debug("sendLog", info(response.body || "OK"));
            await Utils.cleanHistoryRecords(history_file);
        } else {
            Utils.debug("sendLog", error("ERROR"));
            Utils.debug("sendLog", response.body || "Respuesta errónea del servidor");
        }
    } catch (err) {
        Utils.debug("sendLog", err || "Error subiendo a servidor");
    }
};
/*
Utils.execTestsJest = (assignment_path) => {
    Utils.debug("execTestsJest", assignment_path);
    return new Promise((resolve) => {
        const fullScore = {"score": 0, "score_total": 0};
        Utils.debug("Call new JEST test suite:");
        //https://nodejs.org/api/child_process.html#child_processspawncommand-args-options
        const { spawn } = require('node:child_process');
        try {            
            const { exec } = require('node:child_process');
            exec('npx jest', {shell: true}, (error, stdout, stderr) => {
            if (error) {
                console.error(`exec error: ${error}`);
                return;
            }
            console.log(`stdout: ${stdout}`);
            console.error(`stderr: ${stderr}`);
            resolve(fullScore);
            });
        } catch (err) {
            console.error(err);
        }        
        
    }
    );
}
*/

Utils.execTestsJest = (tests_folder, use_jest_native=false) => {
    Utils.devLog("execTestsJest", tests_folder);
    return new Promise((resolve) => {
        const fullScore = {"score": 0, "score_total": 10};
        Utils.debug("Ejecutando nueva test suite de JEST.");
        Utils.debug("Ficheros de tests en la ruta: " + tests_folder);
        const { runCLI } = require('@jest/core');
        const cliOptions = {
            "testMatch": [ "**/**/*.[jt]s?(x)"],
            "roots": ["<rootDir>"+ tests_folder],
            "verbose": true,            
            "testTimeout": 60000,
            "setupFilesAfterEnv": [
                "@testing-library/jest-native/extend-expect"
            ],
            "transformIgnorePatterns": [
                "/node_modules/(?!(@react-native|react-native)/).*/",
                "^.+\\.module\\.(css|sass|scss)$"
            ],            
            "transform": {
                "^.+\\.(js|jsx|mjs|cjs|ts|tsx)$": "<rootDir>/node_modules/autocorector/scripts/jest/babelTransform.js",
                "^.+\\.css$": "<rootDir>/node_modules/autocorector/scripts/jest/cssTransform.js",
                "^(?!.*\\.(js|jsx|mjs|cjs|ts|tsx|css|json)$)": "<rootDir>/node_modules/autocorector/scripts/jest/fileTransform.js"
            },
            "maxWorkers": "1",
            "transformIgnorePatterns": [
                "^.+\\.module\\.(css|sass|scss)$"
            ],
            "modulePaths": [],
            "moduleNameMapper": {
              "^.+\\.module\\.(css|sass|scss)$": "identity-obj-proxy"
            },
            "moduleFileExtensions": [
              "js",
              "jsx"
            ],
            "reporters": [
                ["<rootDir>/node_modules/autocorector/scripts/jest/custom-reporter.js", {"banana": "yes", "pineapple": "no"}]
            ],
            "testSequencer": "<rootDir>/node_modules/autocorector/scripts/jest/test-sequencer.js"
        };
        if(use_jest_native){
            cliOptions.setupFilesAfterEnv = ["@testing-library/jest-native/extend-expect"];
            cliOptions.preset= "jest-expo";
        } else {
            cliOptions.setupFilesAfterEnv = ["<rootDir>/node_modules/autocorector/scripts/jest/jest-setup.js"];
            cliOptions.testEnvironment = "jsdom";
        }
        //otra alternativa que probé sería hacer las siguientes 5 lineas en lugar de runCLI, pero habría que añadir un fichero jest.config.js con module.exports = {laconfig}
        //const jest = require('jest');
        //const argv = [];
        //jest.run(argv);
        //Utils.debug("JEST test suite finished with success");
        //resolve(fullScore);

        runCLI({config: JSON.stringify(cliOptions)}, [process.cwd()]).then((success) => {
            Utils.debug("JEST test suite terminada con éxito.");
            //success contiene los resultados de los tests
            //success.results.testResults es un array con un result para cada test-suite
            //success.results.testResults[0].testResults son los resultados del primer test-suite
            for(let i = 0; i < success.results.testResults.length; i++){
                for(let j = 0; j < success.results.testResults[i].testResults.length; j++){
                    if(success.results.testResults[i].testResults[j].status === "passed"){
                        let myinfo = JSON.parse(success.results.testResults[i].testResults[j].title);
                        fullScore.score += myinfo.score;
                    }
                }
            }
            resolve(fullScore);
        })
        .catch((failure) => {
            Utils.debug("JEST test suite terminada con un error:");
            console.error(failure);
            resolve(fullScore);
        });
    } 

    );
}



Utils.execTests = (tests_folder) => {
    Utils.devLog("execTests", tests_folder);
    return new Promise(async (resolve) => {
        // Define globalshould
        // eslint-disable-next-line global-require
        global.should = require("chai").should();
        // eslint-disable-next-line global-require
        global.exec = nodeutil.promisify(require("child_process").exec);
        // eslint-disable-next-line global-require
        global.Browser = require("zombie");
        const fullScore = {"score": 0, "score_total": 0};
        let files;

        Utils.debug("Call new Mocha test suites:");
        const mymocha = new Mocha({
            "timeout": 60 * 1000,
            // eslint-disable-next-line
            "reporter": function () {   }
        })
        try {
            files = await fs.readdir(tests_folder);
            for (const file of files) {
                Utils.debug("Añadiendo fichero de test: " + file);
                mymocha.addFile(path.join(tests_folder, file));
            }
        } catch (err) {
            console.error(err);
        }       
        //console.log('Version: ' + process.version);

        mymocha.loadFilesAsync()
        .then(() => {
            mymocha.run(failures => process.exitCode = failures ? 1 : 0).
            on("suite", function (suite) {
                console.log(`${suiteTitle(suite.title)}\n`);
            }).
            on("test", function (test) {
                console.log(testTitle(`Test: ${test.title}`));
            }).
            on("pass", function (test) {
                fullScore.score += test.ctx.score;
                fullScore.score_total += test.ctx.score;
                console.log(`\t${highlight("ESTADO: ")}${testTitle("PASSED")}`);
                console.log(`\t${highlight("PUNTUACIÓN: ")}${test.ctx.score}/${test.ctx.score}`);
                console.log(`\t${highlight("OBSERVACIONES: ")}${test.ctx.msg_ok} \n`);
                console.log(`${blueinfo("--------------------------------------------------------------------------------")} \n`);
            }).
            on("fail", function (test, err) {
                try {                    
                    if (test.title.indexOf("\"after all\" hook") < 0 && test.title.indexOf("\"before all\" hook") < 0) {
                        fullScore.score_total += test.ctx.score;
                        console.log(`\t${highlight("ESTADO: ")}${error("FAILED")}`);
                        console.log(`\t${error("PUNTUACIÓN: ")}0/${test.ctx.score}`);                    
                        console.log(`\t${error("OBSERVACIONES:")}${test.ctx.msg_err}`);
                    } else {
                        console.log(error("ERROR TEST MOCHA: ") + err);
                    }
                    Utils.debug(error("Ha fallado el test o se ha producido una excepción."));
                    Utils.debug("El error es:", err);
                    //regexp to find the line number and the corresponding test that failed, it is betweeen parenthesis
                    //const regExp = /\((.+js.+?)\)/g;
                    const regExp = new RegExp('\\((.+('+files.join("|")+').+?)\\)', 'g');
                    const mymatch = err.stack.match(regExp);
                    if (mymatch) {                            
                        let line = mymatch[0];                        
                        //regexp to extract the line number from the error, it is between colons
                        //const re2 = /\:(\d*?)\:/;
                        const re2 = new RegExp('\\:(\\d*?)\\:');
                        const linenumber = line.match(re2);
                        //get filename from the line
                        const testfailed = line.split(":"+linenumber[1]+":")[0];
                        if(linenumber.length>=0 && !testfailed.startsWith("node_modules")){
                            console.log(magentainfo(`\tEl test que ha fallado está en el fichero: ${testfailed.substr(1)} en la línea ${linenumber[1]}. Puedes abrir el fichero y ver qué comprobación está fallando.\n`) );
                        }                        
                    }
                    console.log(`${blueinfo("--------------------------------------------------------------------------------")} \n`);
                } catch (err) {
                    console.log(err);
                }
            }).
            on("end", function () {
                fullScore.score = parseFloat(fullScore.score.toPrecision(12));
                fullScore.score_total = parseFloat(fullScore.score_total.toPrecision(12));
                resolve(fullScore);
            });
        })
        .catch((e) => {
            console.log("CATCH: ", e);
        });
            
    });
};

Utils.initHistory = async () => {
    Utils.devLog("initHistory");
    const history = [];
    const first_history_entry = {};
    const stats = await fs.stat("package.json");

    first_history_entry.started = true;
    first_history_entry.datetime = stats.mtime;
    if (MIRIADAX) {
        first_history_entry.userId = Utils.generateRandomUserId();
    }
    history.push(first_history_entry);
    return history;
};

Utils.saveHistoryRecord = async (fullScore, version, history_file) => {
    Utils.devLog("saveHistoryRecord", fullScore, version);
    let history = false;

    if (!await Utils.checkFileExists(path.resolve(process.cwd(), history_file))) {
        history = await Utils.initHistory();
    } else {
        try {
            const history_enc_content = await fs.readFile(path.resolve(process.cwd(), history_file), "utf8");
            const history_content = Utils.de(history_enc_content, "pubkey.pem");

            history = JSON.parse(history_content);
        } catch (err) {
            console.log("ERROR Recuperable: ", error(err));
            Utils.debug(err);
            history = await Utils.initHistory();
        }
    }
    const new_history_entry = {"started": false, "datetime": new Date(), "score": fullScore.score, "score_total": fullScore.score_total, version, autoCOREctorVersion: AUTOCORECTOR_VERSION};

    history.push(new_history_entry);
    const history_data_enc = Utils.en(JSON.stringify(history, null, 4), "pubkey.pem");

    try {
        await fs.writeFile(path.resolve(process.cwd(), history_file), history_data_enc, "utf8");
        return history;
    } catch (err) {
        console.log(error(err));
        return err;
    }
};


Utils.cleanHistoryRecords = async (history_file) => {
    Utils.devLog("cleanHistoryRecords");
    if (await Utils.checkFileExists(path.resolve(process.cwd(), history_file))) {
        const history_enc_content = await fs.readFile(path.resolve(process.cwd(), history_file), "utf8");
        const history_content = Utils.de(history_enc_content, "pubkey.pem");
        const old_history = JSON.parse(history_content);
        const new_history = [old_history[0]];
        const history_data_enc = Utils.en(JSON.stringify(new_history, null, 4), "pubkey.pem");

        return fs.writeFile(path.resolve(process.cwd(), history_file), history_data_enc, "utf8");
    }
};

module.exports = Utils;
