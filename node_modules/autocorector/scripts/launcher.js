#!/usr/bin/env node

const fs = require("fs").promises;
const path = require("path");
const chalk = require("chalk");
const Utils = require("./utils.js");

//CONSTANTS:
const TESTS_FOLDER = "./autocorector/tests";
const UTILS_FOLDER = "./autocorector/utils";
const DATA_FOLDER = "./autocorector/data";
const CAPTURES_FOLDER = "capturas";
const USER_FILE_PATH = "./user.json";
const OUTPUT_FILE = `${DATA_FOLDER}/res.enc`;
const ZIP_FILE = `${DATA_FOLDER}/assignment.zip`;
const HISTORY_FILE = `${DATA_FOLDER}/his.enc`;
const MAX_FILE_SIZE_MB = 20;

//COLORS:
const blueinfo = chalk.blue;
const error = chalk.bgRed;
const info = chalk.green;
const finalInfoBad = chalk.bgRed;
const finalInfoGood = chalk.bgGreen;

const {MIRIADAX} = process.env;

process.env.BABEL_ENV = 'development';


//GET THE CONFIG FROM PACKAGE.JSON AND EXEC TESTS:
Utils.getConfig().then(async (CONFIG) => {    
    console.log('La versión de Node es: ' + process.version);
    if(+process.version.substring(1,3) < 16) {
        console.log('Tiene una versión de Node inferior a la 16. Este programa solo funciona con Node > 16');
        console.log('Actualice su versión de node y reinicie el pc. De tal modo que al ejecutar el comando "node -v" de como resultado una versión superior a la 16');
        process.exit(0);
    }
    
    let argvoptions = Utils.processArguments(process.argv);
    if(argvoptions.saveLog){
        const myfilehandle = await fs.open(path.resolve(process.cwd(), argvoptions.saveLogFilename), "w");
        const output = myfilehandle.createWriteStream();
        process.stdout.write = process.stderr.write = output.write.bind(output);
        //forzamos todos los mensajes de depuración
        CONFIG.devLogs = true;
        CONFIG.debug = true;
    }
    //we set the debug option to true if it is set in the package.json (it can be also an argument to the program)
    if(CONFIG.debug) {
        console.log("DEBUG MODE ACTIVADO VIA PACKAGE.JSON CONFIG");
        Utils.setDebug(CONFIG.debug);
    }
    if(CONFIG.devLogs){
        console.log("DEVLOGS MODE ACTIVADO VIA PACKAGE.JSON CONFIG");
        Utils.setDevLogs(CONFIG.devLogs);
    }
    if(CONFIG.usejest){
        console.log("JEST ACTIVADO VIA PACKAGE.JSON CONFIG");
        argvoptions.jest = true;
    }
    if(CONFIG.usejestnative){
        console.log("JEST NATIVE ACTIVADO VIA PACKAGE.JSON CONFIG");
        argvoptions.jestnative = true;
    }

    try {
        // FETCH latest version from github for this tests and check, returns "*" if there was a problem checking
        const remVersion = await Utils.checkTestVersion(CONFIG.info.githubURL, "package.json", CONFIG.info.branch);

        if (!argvoptions.upload && remVersion === "*") {
            console.log(info(`No se ha podido comprobar si tienes la última versión de los test, no hay conexión a Internet o el repositorio remoto ha devuelto un error al intentar acceder. Se empleará la versión ${CONFIG.version}`));
        } else if (remVersion !== CONFIG.version) {
            Utils.debug("Version de los test del repositorio es: " + remVersion + " y tu version es: " + CONFIG.version);
            console.log(error("No tienes la última versión de los TESTs o no tienes conexión de red. Debes tener conexión de red y además tener la última versión de los test, para ello actualiza el repositorio."));
            console.log(info(`Si has utilizado git para bajártelo tan solo tendrás que hacer git pull, si no has usado git vuelve a bajarte el repo completo y sustituye la carpeta ${TESTS_FOLDER} y el fichero package.json por la última versión.`));
        }
        if (argvoptions.upload && remVersion !== CONFIG.version) {
            Utils.debug("No se puede subir la práctica por no coincidir la versión de los tests");
            process.exit(0);
        }

        if (CONFIG.localHashCheck) {
            Utils.debug("Vamos a comprobar el hash de los ficheros de test");
            await Utils.checkHash(CONFIG.info.githubURL, TESTS_FOLDER, UTILS_FOLDER);
        } else {
            Utils.debug("WARNING: DisableHashCheck opción a 'true', saltando hash check");
        }
        
        const autoCOREctorURL = `${CONFIG.info.serverUrl}api/${MIRIADAX ? "coursesMiriadax" : "courses"}/${CONFIG.info.courseId}/assignments/${CONFIG.info.assignmentId}`;

        await Utils.createFolder(DATA_FOLDER);
        let user_info = await Utils.getEmailAndToken(USER_FILE_PATH,CONFIG.info.serverUrl);
        let fullScore ;
        if (argvoptions.jest || argvoptions.jestnative) {
            Utils.debug("Ejecutando tests con JEST");
            fullScore = await Utils.execTestsJest(TESTS_FOLDER, argvoptions.jestnative);
        } else {
            Utils.debug("Ejecutando tests con MOCHA");
            fullScore = await Utils.execTests(TESTS_FOLDER);
        }
        const history = await Utils.saveHistoryRecord(fullScore, CONFIG.version, HISTORY_FILE);

        // process score y score_total para evitar problema de punto flotante
        if (fullScore.score === (fullScore.score_total || 10)) {
            console.log(finalInfoGood(`Resultado Final: ${fullScore.score}/${fullScore.score_total}\n\n`));
        } else {
            console.log(finalInfoBad(`Resultado Final: ${fullScore.score}/${fullScore.score_total}\n\n`));
        }

        if(argvoptions.saveLogs){
            myfilehandle.close();
            console.log(finalInfoGood(`Se ha creado el fichero ${argvoptions.saveLogFilename} con los logs de la práctica, ya los puedes mandar junto con el zip de la práctica (sin node_modules) al profesor.`));
            process.exit(0);
        }

        if (argvoptions.upload) {
            const dataCorrect = await Utils.askForDataCorrect(user_info);

            if (!dataCorrect) {
                // remove user.json (if exists)
                if (await Utils.checkFileExists(path.resolve(process.cwd(), USER_FILE_PATH))) {
                    await fs.unlink(path.resolve(process.cwd(), USER_FILE_PATH));
                }
                user_info = await Utils.getEmailAndToken(USER_FILE_PATH,CONFIG.info.serverUrl);
            }
            const consent = await Utils.askForConsent();

            if (!consent) {
                console.log(error("Asegurese de haber hecho usted la práctica que va a subir al servidor."));
                process.exit(0);
            }
            if(CONFIG.capturesNumber && CONFIG.capturesNumber > 0){
                const final_captures_folder = CONFIG.capturesFolder === undefined ? CAPTURES_FOLDER : CONFIG.capturesFolder;
                const has_captures = await Utils.checkCaptures(final_captures_folder, CONFIG.capturesNumber);
                if(!has_captures){
                    console.log(error(`No se han encontrado las capturas de pantalla requeridas. Se necesitan ${CONFIG.capturesNumber} capturas en el directorio ${path.resolve(process.cwd(), final_captures_folder)}`));
                    process.exit(0);
                }
            }
            user_info.score = fullScore.score;
            user_info.score_total = fullScore.score_total;
            user_info.test_version = CONFIG.version;
            user_info.history = history;
            const user_info_clon = JSON.parse(JSON.stringify(user_info));

            user_info.signature = Utils.getSignature(user_info_clon);
            Utils.devLog("RESULTS: ", user_info);
            const result_data = Utils.en(JSON.stringify(user_info, null, 4), "pubkey.pem");

            await fs.writeFile(path.resolve(process.cwd(), OUTPUT_FILE), result_data);
            const fileSizeInMegabytes = await Utils.compress(ZIP_FILE);
            if(fileSizeInMegabytes > MAX_FILE_SIZE_MB) {
                console.log(error(`ERROR CRITICO. El fichero zip creado para la práctica supera el tamaño máximo permitido de ${MAX_FILE_SIZE_MB}MB. El corrector comprime todo lo que está en la carpeta del proyecto excepto el node_modules, asegurese de que no ha puesto archivos adicionales en la carpeta de la práctica, solo los requeridos para solucionarla.`));
            } else {
                await Utils.sendFile(autoCOREctorURL, ZIP_FILE, HISTORY_FILE);
            }
            Utils.debug("¡FIN!");
        } else {
            console.log(finalInfoBad("Este resultado es informativo. Debe ejecutar el autocorector con la opción -u o --upload para subir su nota y que quede registrada."));
            console.log(finalInfoGood("Recuerde que puede subir su nota varias veces, se quedará con la última nota que haya subido cuando se cierre la entrega de la práctica."));
        }
    } catch (err) {
        console.log("ERROR, CERRAMOS TODO");
        console.log(error(err));
        console.log(err)
    }
}).catch((err) => {
    Utils.debug(err);
    console.log(error(err));
});


